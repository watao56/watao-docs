# 実例：プロジェクト構築の全工程

Claude Code を使って Web アプリケーションをゼロから構築し、デプロイするまでの全工程を解説する。Next.js + shadcn/ui を使ったフロントエンドプロジェクトを例に、実際の開発フローを追体験できるガイド。

---

## 全体の流れ

```
1. 要件定義・技術選定        ← Plan Mode
2. プロジェクト初期化        ← スキャフォールディング
3. 基盤実装                  ← レイアウト、ルーティング、型定義
4. 機能実装                  ← サブエージェントで並列化
5. 外部サービス連携          ← API / CDN 統合
6. ビルド・エラー修正        ← デバッグ
7. テスト・品質保証          ← 自動テスト
8. デプロイ                  ← CI/CD
```

各フェーズで Claude Code をどう活用するかを具体的に見ていく。

---

## Phase 1: 要件定義・技術選定

### Plan Mode で構成を検討

まず Plan Mode（`Shift+Tab`）に切り替えて、実装に入る前に計画を立てる。

```
以下の要件で Web アプリケーションを構築したい：

【目的】
ユーザーがデータを視覚的に編集・管理できるツール

【要件】
- レスポンシブ UI
- ドラッグ&ドロップ対応
- リアルタイムプレビュー
- データのインポート/エクスポート（JSON, CSV）
- 外部 CDN からのアセット読み込み

技術スタックを提案して。メリット・デメリットも含めて。
```

Claude が以下のような提案をしてくれる：

```
提案する技術スタック：
- フレームワーク: Next.js 15 (App Router)
  → SSR/SSG対応、ファイルベースルーティング
- UI: shadcn/ui + Tailwind CSS
  → カスタマイズ性が高く、コピー&ペーストで導入
- 状態管理: Zustand
  → シンプルで軽量、TypeScript との相性が良い
- D&D: @dnd-kit/core
  → 軽量でアクセシビリティ対応
- フォーム: React Hook Form + Zod
  → 型安全なバリデーション
```

!!! tip "技術選定の議論"
    Plan Mode では Claude と対話的に技術選定を進められる。「なぜ Zustand を選んだのか？Redux Toolkit との比較は？」のような質問を重ねて、納得のいく選定をしよう。

### ディレクトリ構成の決定

```
以下のディレクトリ構成を提案して：
- App Router ベース
- 機能ごとのディレクトリ分割
- 共通コンポーネント、フック、ユーティリティの配置
- 型定義ファイルの配置

テキストのツリー形式で見せて。
```

---

## Phase 2: プロジェクト初期化

### スキャフォールディング

Plan Mode を解除（`Shift+Tab`）して、実装に入る。

```
計画に基づいてプロジェクトを初期化して：

1. npx create-next-app@latest でプロジェクト作成
   - TypeScript, Tailwind CSS, ESLint, App Router を有効化
   - src/ ディレクトリを使用
2. shadcn/ui を初期化して基本コンポーネントを追加
   （Button, Card, Dialog, Input, Select, Tabs, Toast）
3. 追加パッケージをインストール
   （zustand, @dnd-kit/core, react-hook-form, zod）
4. ディレクトリ構成を作成
5. 基本的な tsconfig.json のパスエイリアスを設定
```

Claude が一連のコマンドを実行し、プロジェクトの骨格を作成してくれる。

### 初期設定ファイルの整備

```
以下の設定ファイルを作成・更新して：

1. .env.example — 必要な環境変数の一覧
2. .eslintrc.json — プロジェクト用のルール追加
3. .prettierrc — コードフォーマット設定
4. .claudeignore — Claude Code が読まない対象
5. CLAUDE.md — プロジェクト固有のルール

CLAUDE.md には以下を含めて：
- ビルド・テストコマンド
- コーディング規約
- ディレクトリ構成の説明
- 使用しているライブラリの説明
```

!!! note "CLAUDE.md を最初に作る"
    プロジェクト初期化直後に CLAUDE.md を作成しておくと、以降の全セッションで Claude が一貫した実装をしてくれる。最初のわずかな投資が後の品質を大きく左右する。

---

## Phase 3: 基盤実装

### レイアウトの構築

```
以下のレイアウトを実装して：

src/app/layout.tsx:
- ヘッダー（アプリ名、ナビゲーション、テーマ切り替え）
- メインコンテンツエリア
- フッター
- ダークモード対応（next-themes）
- Toast プロバイダー

@src/components/ui/ の shadcn コンポーネントを使って。
レスポンシブ対応も忘れずに。
```

### 型定義の作成

```
アプリケーションのコアとなる型定義を作成して：

src/types/index.ts:
- ユーザーが編集するデータの型
- UI の状態型（選択状態、フィルター状態など）
- API レスポンスの型
- 設定の型

Zod スキーマも同時に定義して、型とバリデーションを一元管理して。
```

### 状態管理のセットアップ

```
Zustand でグローバル状態管理を実装して：

src/store/index.ts:
- データ一覧の状態
- 選択状態
- フィルター・ソート状態
- CRUD 操作のアクション
- persist ミドルウェアで localStorage に保存

型安全に実装して。スライスパターンで分割して。
```

---

## Phase 4: 機能実装（サブエージェントで並列化）

### 並列実装の戦略

複数の独立した機能を同時に実装する。これが Claude Code の真価を発揮する場面。

```
以下の3つの機能をサブエージェントで並列に実装して：

【エージェント1: データ一覧ページ】
- src/app/page.tsx のメインページ
- フィルター・検索・ソート機能
- データカードのグリッド表示
- ページネーション

【エージェント2: データ編集ダイアログ】
- src/components/editor/EditDialog.tsx
- フォーム（React Hook Form + Zod バリデーション）
- リアルタイムプレビュー
- 保存・キャンセル操作

【エージェント3: インポート/エクスポート】
- src/lib/import-export.ts
- JSON / CSV インポート
- JSON / CSV エクスポート
- バリデーションとエラーハンドリング

各機能は異なるファイルを編集するので並列で問題なし。
完了後にビルドして統合テストを行って。
```

!!! warning "並列実装の注意点"
    - 同じファイルを編集するタスクは並列にしない
    - 共有の型定義は事前に確定させておく
    - 統合後は必ずビルドとテストを実行する

### 各機能の詳細な実装指示

実装中に問題が見つかったら、その場で修正を指示する：

```
データ一覧ページで、フィルターの状態が URL パラメータに反映されていない。
useSearchParams を使って URL と同期させて。
ブラウザの戻るボタンでフィルターが復元されるようにして。
```

### コンポーネントの統合

並列実装が完了したら、統合作業：

```
3つの機能を統合して：
1. メインページにインポート/エクスポートボタンを追加
2. データカードのクリックで編集ダイアログを開く
3. 編集の保存で一覧が更新される
4. ビルドエラーがないことを確認
5. 基本的な動作フロー（一覧 → 編集 → 保存 → 一覧更新）をテスト
```

---

## Phase 5: 外部サービス連携

### 外部 API の統合

```
外部 API からデータを取得する機能を追加して：

src/lib/api-client.ts:
- fetch ベースの API クライアント
- リトライロジック（指数バックオフ）
- エラーハンドリング（HTTPエラー、ネットワークエラー）
- 型安全なレスポンスパース
- レート制限の考慮

src/hooks/useExternalData.ts:
- SWR または React Query でデータフェッチ
- ローディング・エラー状態の管理
- キャッシュ戦略
```

### CDN アセットの読み込み

```
外部 CDN からアセット（画像、アイコン）を読み込む機能を実装して：

1. next.config.js に外部画像ドメインを追加
2. CDN URL のヘルパー関数を作成
3. 画像コンポーネント（遅延読み込み、フォールバック、エラーハンドリング）
4. アセットのプリロード機能

パフォーマンスを意識して：
- next/image の最適化を活用
- 適切な sizes 属性
- placeholder="blur" 対応
```

### 環境変数の管理

```
環境変数のバリデーションを実装して：

src/lib/env.ts:
- Zod で全環境変数をバリデーション
- 起動時に不足をチェック
- 型安全にアクセスできるようにエクスポート

.env.example も更新して。
```

---

## Phase 6: ビルド・エラー修正

### よくあるビルドエラーとその対処

実際のプロジェクトでは、ビルドエラーとの戦いが避けられない。

#### 型エラーの修正

```
npm run build でTypeScriptエラーが出ている。全て修正して：

[ビルド出力を貼り付け]

型アサーション（as）ではなく、適切な型定義で解決して。
```

#### SSR 関連のエラー

```
Next.js のビルドで "window is not defined" エラーが出ている。
SSR で window を参照しているコンポーネントを特定して修正して。

対策として：
- dynamic import with { ssr: false }
- useEffect 内に移動
- typeof window !== 'undefined' チェック

適切な方法を選択して。
```

#### 依存関係の問題

```
npm run build で以下の警告/エラーが出ている：
[エラー出力]

パッケージの互換性問題を調査して解決して。
npm ls で依存関係を確認して。
```

!!! tip "ビルドエラーはパイプで渡す"
    ```bash
    npm run build 2>&1 | claude -p 'このビルドエラーを修正して。根本原因を直して。'
    ```

### 段階的なエラー修正

```
ビルドエラーが複数ある場合は：
1. まずエラーの一覧を確認
2. 依存関係のあるエラーを特定（1つ直すと他も直るケース）
3. ルートコーズから順に修正
4. 1つ修正するごとに再ビルドして確認
5. 全エラーが解消されたら最終ビルド
```

---

## Phase 7: テスト・品質保証

### テストの追加

```
以下の優先順位でテストを追加して：

1. ユーティリティ関数のユニットテスト（src/lib/）
2. Zustand ストアのテスト
3. 主要コンポーネントのレンダリングテスト
4. API クライアントのテスト（MSW でモック）
5. インポート/エクスポートの統合テスト

Vitest + React Testing Library を使って。
各テストファイル作成後にテスト実行して確認して。
```

### Lint・型チェックの徹底

```
以下の品質チェックを全て通して：
1. npm run lint -- 警告もゼロにして
2. npm run typecheck -- strict モードで
3. npm run build -- 成功すること
4. npm test -- 全テストパス

問題があれば修正して。
```

---

## Phase 8: デプロイ

### Vercel へのデプロイ設定

```
Vercel デプロイの準備をして：

1. vercel.json を作成（リダイレクト、ヘッダー設定）
2. 環境変数の一覧を .env.example に反映
3. ビルドが成功することを最終確認
4. README にデプロイ手順を追加
```

### GitHub Pages へのデプロイ（静的サイトの場合）

```
GitHub Pages デプロイの設定をして：

1. next.config.js に output: 'export' を追加
2. GitHub Actions ワークフローを作成
3. ビルド → デプロイの自動化
4. カスタムドメインの設定（必要な場合）
```

### デプロイ後の確認

```
デプロイ後の確認リストを作成して実行して：

□ トップページが正常に表示される
□ 全ナビゲーションリンクが動作する
□ データの作成・編集・削除が動作する
□ インポート/エクスポートが動作する
□ レスポンシブデザインが正常（モバイル表示）
□ ダークモード切り替えが動作する
□ 外部 CDN アセットが読み込まれる
□ ブラウザコンソールにエラーがない
□ パフォーマンス（Lighthouse スコア）が許容範囲内
```

---

## 開発中に学んだ教訓

### ✅ うまくいったこと

| パターン | 効果 |
|---------|------|
| Plan Mode で事前に計画 | 手戻りが大幅に減った |
| 型定義を先に確定 | 並列実装がスムーズに |
| サブエージェントの並列実装 | 開発速度が 2-3 倍に |
| CLAUDE.md の早期作成 | 一貫した実装品質 |
| 段階的なビルド確認 | エラーの早期発見 |

### ❌ 注意すべきこと

| アンチパターン | 問題 | 対策 |
|-------------|------|------|
| 一度に全て依頼 | コンテキスト溢れ、品質低下 | スコープを絞る |
| 曖昧な指示 | 意図と異なる実装 | 具体的なファイル・関数を指定 |
| テストなしで進行 | 後半で大量のバグ | 実装と同時にテスト |
| /clear を忘れる | コンテキスト劣化 | タスク完了ごとに /clear |
| 共有ファイルの並列編集 | コンフリクト | 共有部分は事前に確定 |

### 💡 プロのコツ

1. **CLAUDE.md は育てる** — プロジェクトの進行に合わせて更新する
2. **検証手段を常に用意** — 「テストを実行して」「ビルドして」を指示に含める
3. **@ 参照を多用する** — 既存コードを参照させることで一貫性が保たれる
4. **エラーはすぐパイプ** — `npm run build 2>&1 | claude` が最速
5. **セッションを分ける** — 機能ごとに別セッションで進める

---

## プロジェクト完成後のメンテナンス

### 継続的な改善

```bash
# 定期的な依存関係の更新
claude -p "npm outdated を確認して、安全に更新できるパッケージを教えて"

# パフォーマンスの改善
claude -p "Lighthouse のスコアを改善するための提案をして"

# セキュリティチェック
claude -p "npm audit を実行して、脆弱性があれば修正して"
```

### 機能追加のワークフロー

新機能を追加する際も、同じフローを繰り返す：

```
1. Plan Mode で設計
2. 型定義の追加
3. 実装（必要に応じてサブエージェントで並列化）
4. テスト追加
5. ビルド確認
6. コミット・PR 作成
```

!!! tip "このフローを習慣にする"
    Claude Code を使った開発は「Plan → 型 → 実装 → テスト → ビルド」のサイクルを回すこと。このフローが身につくと、一人で数人分の生産性が出せるようになる。

# 実践活用事例集

Claude Code を実際の開発現場で活用するための具体的なユースケース集。プロジェクト立ち上げからデプロイまで、あらゆる場面での実践的な使い方を解説する。

---

## プロジェクト立ち上げ（スキャフォールディング）

### ゼロからのプロジェクト生成

Claude Code はプロジェクトの雛形を一から作成できる。フレームワークの選定から設定ファイルの生成まで、対話的に進められる。

#### 基本的なプロンプト例

```
Next.js 15 + TypeScript + Tailwind CSS + shadcn/ui でプロジェクトを作成して。
以下の要件：
- App Router 使用
- src/ ディレクトリ構成
- ESLint + Prettier 設定済み
- 基本的なレイアウト（ヘッダー、サイドバー、メインコンテンツ）
```

#### より具体的な指示

```
以下の構成で REST API サーバーを作成して：
- Express.js + TypeScript
- Prisma ORM（PostgreSQL）
- JWT 認証
- OpenAPI (Swagger) ドキュメント自動生成
- Docker Compose で DB 含めた開発環境
- テスト: Vitest + Supertest

まず構成を計画して、確認してから実装に入って。
```

!!! tip "Plan Mode を活用する"
    `Shift+Tab` で Plan Mode に切り替えると、Claude は実装前に計画を立ててくれる。大規模なスキャフォールディングでは必ず Plan Mode で構成を確認してから実装に移ろう。

#### モノレポの構築

```
Turborepo でモノレポを構築して：
- apps/web: Next.js フロントエンド
- apps/api: Express バックエンド
- packages/ui: 共有 UI コンポーネント
- packages/types: 共有型定義
- packages/config: 共有設定（ESLint, TypeScript）

各パッケージ間の依存関係も設定して。
```

### 既存プロジェクトへの機能追加

```
このプロジェクトに認証機能を追加して：
- NextAuth.js v5 を使用
- Google OAuth + メール/パスワード認証
- Prisma でユーザーモデルを追加
- ミドルウェアで保護ルートを設定
- 既存のレイアウトにログイン/ログアウトボタンを追加

@prisma/schema.prisma を見て既存のスキーマに合わせて。
```

!!! note "@ 参照を活用"
    `@ファイルパス` で既存ファイルを参照させると、Claude はそのファイルの内容を読んだ上で一貫性のある実装を行う。

---

## 大規模リファクタリング

### マルチファイルリファクタリング

Claude Code の真価が発揮される場面。複数ファイルにまたがる変更を一貫性を保ちながら実行できる。

#### API レスポンス形式の統一

```
src/api/ 以下の全エンドポイントのレスポンス形式を統一して：

現在: 各エンドポイントがバラバラな形式で返している
目標: { success: boolean, data?: T, error?: { code: string, message: string } }

以下の手順で：
1. まずレスポンスの型を定義
2. ヘルパー関数を作成
3. 全エンドポイントを段階的に修正
4. 修正ごとにテストを実行して確認
```

#### クラスコンポーネントから関数コンポーネントへの移行

```
src/components/ 以下のクラスコンポーネントを関数コンポーネントに移行して：
- setState → useState
- componentDidMount → useEffect
- componentWillUnmount → useEffect のクリーンアップ
- this.props → 引数のデストラクチャリング
- 1ファイルずつ変換して、各ファイルの変換後にビルドが通ることを確認

まず対象ファイルをリストアップして。
```

!!! warning "段階的に進める"
    大規模リファクタリングでは、一度に全てを変更せず段階的に進めることが重要。各ステップでテストを実行し、問題がないことを確認してから次に進もう。

#### インポートパスの整理

```
プロジェクト全体で相対パスインポートを tsconfig の paths エイリアスに変更して：
- ../../../components/ → @/components/
- ../../../lib/ → @/lib/
- ../../../types/ → @/types/

tsconfig.json の paths 設定も更新して。
影響するファイルが多いので、ディレクトリ単位で進めて。
```

### レガシーコードのモダナイゼーション

#### コールバックから async/await への移行

```
src/services/ 以下のコールバックベースの非同期処理を
async/await に変更して。

注意点：
- エラーハンドリングは try/catch に変換
- Promise.all で並列化できる箇所は並列化
- 既存のテストも更新
- 1サービスファイルずつ変換して検証
```

#### ORM の移行

```
Sequelize から Prisma への移行を実施して：

1. 既存の Sequelize モデルから Prisma スキーマを生成
2. マイグレーションファイルを作成
3. リポジトリ層のコードを Prisma Client に書き換え
4. 既存テストを更新
5. 型安全性が向上していることを確認

@models/ の既存モデルを確認してから始めて。
```

---

## バグ調査・デバッグ

### エラーログからの原因特定

Claude Code はエラーメッセージから根本原因を探り、修正まで行える。

#### 基本パターン

```
以下のエラーが発生している：

TypeError: Cannot read properties of undefined (reading 'map')
  at UserList (src/components/UserList.tsx:23:18)
  at renderWithHooks (node_modules/react-dom/...)

原因を調査して修正して。修正後にテストも追加して。
```

#### ビルドエラーの修正

```
npm run build で以下のエラーが出る：

[paste build output]

ルートコーズを修正して。エラーを抑制するのではなく根本原因を直して。
ビルドが成功することを確認して。
```

!!! tip "エラー出力をパイプで渡す"
    ```bash
    npm run build 2>&1 | claude -p 'このビルドエラーの根本原因を説明して修正して'
    ```
    コマンド出力を直接パイプで渡すのも効果的。

#### パフォーマンス問題の調査

```
/api/users エンドポイントのレスポンスが遅い（3秒以上かかる）。
原因を調査して：

1. まずルートハンドラのコードを確認
2. DB クエリを特定（N+1 問題がないか）
3. 不要な処理がないか確認
4. 改善案を提示して実装

@src/api/routes/users.ts から始めて。
```

### 再現困難なバグの調査

```
ユーザーから「たまにログインできない」という報告がある。
以下の情報がある：
- 発生頻度: 10回に1回程度
- 環境: Chrome, Safari 両方
- エラーログ: [paste logs]

認証フローのコードを調査して、レースコンディションや
タイミング依存の問題がないか確認して。
```

### Git の履歴を使った調査

```
UserProfile コンポーネントが先週から壊れている。
git log と git diff を使って、いつ壊れたか特定して。
原因のコミットを見つけたら修正して。
```

!!! note "Git 連携の活用"
    Claude Code は `git log`, `git diff`, `git blame` などを使いこなせる。「いつから壊れたか」を調査させるのに非常に効果的。

---

## テスト作成

### 既存コードへのテスト追加

#### 単体テストの生成

```
src/utils/validation.ts にテストを書いて：
- 正常系・異常系をカバー
- エッジケース（空文字、null、undefined、極端に長い文字列）
- 既存テストのスタイルに合わせて（@src/utils/__tests__/ を参照）
- カバレッジ 90% 以上を目標に
```

#### 統合テストの生成

```
/api/orders エンドポイントの統合テストを書いて：
- POST /api/orders（注文作成）
- GET /api/orders/:id（注文取得）
- PATCH /api/orders/:id（注文更新）
- DELETE /api/orders/:id（注文削除）

テストデータベースのセットアップ/クリーンアップも含めて。
既存のテストヘルパー @src/test/helpers.ts を使って。
```

#### E2E テストの生成

```
Playwright でログインフローの E2E テストを書いて：
1. ログインページにアクセス
2. メールアドレスとパスワードを入力
3. ログインボタンをクリック
4. ダッシュボードにリダイレクトされることを確認
5. ヘッダーにユーザー名が表示されることを確認
6. ログアウトして再度ログインページに戻ることを確認

@playwright.config.ts の設定を確認してから書いて。
```

### テストの改善

#### カバレッジの向上

```
npm run test:coverage の結果を見て、カバレッジが低いファイルを特定して。
最もカバレッジが低い上位3ファイルにテストを追加して。
各ファイルのテスト追加後にカバレッジレポートを再生成して改善を確認して。
```

#### フレークテストの修正

```
以下のテストがランダムに失敗する：
@src/__tests__/async-handler.test.ts

原因を調査して修正して。タイミング依存やテスト間の依存を確認して。
```

!!! tip "テスト駆動で開発させる"
    ```
    まずテストを書いて、テストが失敗することを確認してから実装して。
    ```
    TDD スタイルの開発も Claude Code に任せられる。

---

## ドキュメント生成

### コードからの自動ドキュメント生成

#### API ドキュメント

```
src/api/routes/ 以下の全エンドポイントを読んで、
API ドキュメントを docs/api.md に生成して：

- 各エンドポイントの URL, メソッド, 説明
- リクエストパラメータ（型、必須/任意、説明）
- レスポンス形式（成功時、エラー時）
- 認証要件
- 使用例（curl コマンド）

既存のドキュメントスタイル @docs/README.md に合わせて。
```

#### README の生成・更新

```
このプロジェクトの README.md を更新して：
- プロジェクト概要
- セットアップ手順（実際に動作する手順）
- 環境変数の一覧（.env.example から）
- 利用可能なスクリプト（package.json から）
- ディレクトリ構成
- コントリビューションガイド

package.json, tsconfig.json, docker-compose.yml を読んで
実際の設定に基づいた正確な情報を書いて。
```

#### JSDoc / TSDoc の追加

```
src/lib/ 以下の公開関数に JSDoc コメントを追加して：
- 関数の説明
- @param の型と説明
- @returns の説明
- @throws があれば記載
- @example で使用例

既に JSDoc がある関数はスキップして。
```

### 変更履歴の自動生成

```
git log --oneline v1.0.0..HEAD を確認して、
CHANGELOG.md を Conventional Commits 形式で生成して：

## [1.1.0] - 2025-xx-xx
### Added
- ...
### Fixed
- ...
### Changed
- ...
```

---

## コードレビュー支援

### PR レビューの自動化

#### 差分のレビュー

```
git diff main...HEAD の変更をレビューして：

以下の観点でチェック：
1. バグの可能性がある箇所
2. パフォーマンスの問題
3. セキュリティリスク
4. コーディング規約違反
5. テスト不足

問題がある場合はファイル名と行番号を含めて報告して。
```

#### CI/CD でのレビュー自動化

```bash
# GitHub Actions での使用例
claude -p "$(gh pr diff $PR_NUMBER)" \
  --output-format json \
  -p 'このPRの差分をレビューして。問題点をJSON配列で返して。
      各要素は {file, line, severity, message} の形式で。'
```

### セキュリティレビュー

```
以下のファイルのセキュリティレビューを行って：
@src/api/routes/auth.ts
@src/middleware/auth.ts
@src/lib/jwt.ts

チェック項目：
- SQL/NoSQL インジェクション
- XSS 脆弱性
- CSRF 対策
- 認証・認可の不備
- シークレットのハードコーディング
- 入力バリデーションの不足
```

!!! warning "AI レビューは補助的に使う"
    Claude Code のレビューは強力だが、セキュリティに関わる重大な変更は必ず人間のレビューも行うこと。AI レビューは見落とし防止の追加レイヤーとして活用しよう。

---

## API 統合

### 外部 API の統合

#### REST API クライアントの作成

```
以下の API を統合して：
- Stripe 決済 API
- エンドポイント: https://api.stripe.com/v1/
- 必要な機能: 顧客作成、支払い意図の作成、Webhook 処理

以下の構成で実装して：
1. API クライアントクラス（リトライ、エラーハンドリング付き）
2. 型定義（Stripe のレスポンス型）
3. Webhook ハンドラ（署名検証付き）
4. 環境変数での設定管理
5. テスト（モックを使用）

@package.json を確認して既存の HTTP クライアントがあれば使って。
```

#### GraphQL API の統合

```
GitHub GraphQL API を使ってリポジトリ情報を取得する機能を実装して：
- graphql-request ライブラリを使用
- クエリ: リポジトリ一覧、Issue 一覧、PR 一覧
- ページネーション対応
- 型安全な実装（codegen 使用）
- レート制限の処理
```

#### OpenAPI からのクライアント生成

```
@openapi.yaml の OpenAPI 定義から API クライアントを生成して：
- openapi-typescript で型を生成
- fetch ベースのクライアントを実装
- リクエスト/レスポンスのバリデーション
- エラーハンドリング（HTTPエラー、ネットワークエラー、タイムアウト）
```

### WebSocket / リアルタイム通信

```
Socket.io を使ったリアルタイムチャット機能を実装して：
- サーバー側: イベントハンドラ（接続、メッセージ送信、退室）
- クライアント側: React カスタムフック（useChat）
- 型安全なイベント定義
- 再接続ロジック
- メッセージの永続化（DB 保存）
```

---

## データベース設計・マイグレーション

### スキーマ設計

#### Prisma スキーマの設計

```
EC サイト用のデータベーススキーマを Prisma で設計して：

必要なモデル：
- User（ユーザー）
- Product（商品）
- Category（カテゴリ）
- Order（注文）
- OrderItem（注文明細）
- Review（レビュー）
- Address（住所）

要件：
- ソフトデリート対応
- 監査カラム（createdAt, updatedAt, createdBy）
- 適切なインデックス
- リレーション定義

まず ER 図（テキスト形式）を作成して確認してから
schema.prisma を生成して。
```

### マイグレーション

#### マイグレーションの作成と実行

```
以下の変更のマイグレーションを作成して：
- users テーブルに profile_image_url カラムを追加（nullable）
- orders テーブルに status カラムを追加（enum: pending, processing, shipped, delivered, cancelled）
- products テーブルに全文検索用のインデックスを追加

既存データへの影響も考慮して。
npx prisma migrate dev --name add-profile-and-order-status で実行して。
```

#### データマイグレーション

```
users テーブルの name カラムを first_name と last_name に分割して：

1. 新カラムを追加するマイグレーション
2. 既存データを移行するスクリプト（name を空白で分割）
3. 古いカラムを削除するマイグレーション

ダウンタイムなしで段階的にデプロイできるようにして。
```

!!! tip "マイグレーションは慎重に"
    ```
    まず Plan Mode でマイグレーション計画を立てて。
    既存データへの影響、ロールバック手順、ダウンタイムの有無を確認してから実行して。
    ```

### シードデータの作成

```
開発用のシードデータを prisma/seed.ts に作成して：
- 管理者ユーザー 1名
- 一般ユーザー 10名（faker.js で生成）
- カテゴリ 5件
- 各カテゴリに商品 10件
- ランダムな注文データ 50件
- レビューデータ 100件

リアルなデータになるように。日本語対応で。
```

---

## DevOps・インフラ

### Docker 環境の構築

```
このプロジェクトの Docker 環境を構築して：

- Dockerfile（マルチステージビルド、本番最適化）
- docker-compose.yml（開発環境: app + DB + Redis）
- docker-compose.prod.yml（本番環境）
- .dockerignore

@package.json を確認してビルドコマンドを把握してから。
```

### CI/CD パイプライン

```
GitHub Actions のワークフローを作成して：

.github/workflows/ci.yml:
- プッシュ時: lint, type-check, test, build
- PR時: 上記 + カバレッジレポート + サイズチェック
- main マージ時: デプロイ

.github/workflows/deploy.yml:
- Vercel へのデプロイ
- 環境変数の設定
- デプロイ後の E2E テスト

キャッシュを効かせてCIを高速化して。
```

### 環境変数の管理

```
プロジェクトの環境変数管理を整理して：
1. .env.example を全変数が含まれた状態に更新
2. 環境変数のバリデーション（zod）を src/lib/env.ts に実装
3. 型安全に使えるようにする
4. README に環境変数の説明を追加
5. CI/CD で必要な変数をリストアップ
```

---

## 実践的なワークフロー例

### 朝のルーティン

```bash
# 1. プロジェクトディレクトリに移動
cd my-project

# 2. Claude Code を起動
claude

# 3. 昨日の作業を確認
> git log --since="yesterday" --oneline を見せて。
> 今開いている PR の状態を gh で確認して。

# 4. 今日のタスクに取りかかる
> Issue #42 を確認して、実装計画を立てて。
```

### 機能開発の流れ

```
1. Issue #42 の内容を gh で確認して
2. feature/issue-42 ブランチを作成
3. Plan Mode で実装計画を立てて確認させて
4. 実装（テスト駆動で）
5. lint, type-check, test 全部通ることを確認
6. コミット（Conventional Commits 形式で）
7. PR を作成（Issue へのリンク付き）
```

### トラブルシューティング

```bash
# ビルドエラーをパイプで渡す
npm run build 2>&1 | claude -p 'このエラーを修正して'

# テスト失敗をパイプで渡す
npm test 2>&1 | claude -p 'このテスト失敗の原因を調査して修正して'

# ログファイルを分析
cat /var/log/app/error.log | claude -p 'このログからエラーパターンを分析して'
```

---

## まとめ

| ユースケース | 効果的なアプローチ |
|------------|------------------|
| プロジェクト立ち上げ | Plan Mode で構成確認 → 段階的に生成 |
| リファクタリング | 1ファイルずつ変換 → 都度テスト実行 |
| デバッグ | エラー出力をパイプ → 根本原因の特定を指示 |
| テスト作成 | 既存テストのスタイルを参照させる |
| ドキュメント | 実際のコードから生成させる |
| コードレビュー | 具体的な観点を指定する |
| API 統合 | 型安全性・エラーハンドリングを明示的に要求 |
| DB 設計 | Plan Mode で設計確認 → マイグレーション |

!!! tip "共通する成功パターン"
    1. **具体的な指示を出す** — 曖昧なプロンプトは曖昧な結果を生む
    2. **検証手段を与える** — テスト実行、ビルド確認を指示に含める
    3. **段階的に進める** — 一度に全てをやらせず、ステップを分ける
    4. **既存パターンを参照させる** — `@` でファイルを指定して一貫性を保つ
    5. **Plan Mode を活用する** — 大きな変更の前に計画を確認する
